# Life Cycle

## Vue Lifecycle

{% file src="../.gitbook/assets/lifecycle.html" caption="이번장의 코드입니다." %}

우리는 `new Vue()` 라는 코드를 통해 Vue instance를 생성합니다. 

그럼 그때부터 **lifeCycle**이 돌기 시작합니다. 

![](../.gitbook/assets/image%20%286%29.png)

위에서부터 살펴보면

1. **이벤트와 라이프사이클을 정의** 
   * `beforeCreate` 함수 실행 \(데이터가 아직 정의되지 않음\)
2. **인젝션\(외부모듈이나 뷰에서 필요한 것들 주입\) & 데이터 반응성 부여\(생성직전\)**
   * `created` 함수 실행 \(일반적으로 많이 실행\)
3. **el이라는 옵션이 있는지, 있다면 template가 있는지 체크**
   * `beforeMounted` 함수 실행 \(html요소가 생성되지 않았기 때문에 뭔가를 걸수가 없다\)
4. **HTML ELEMENT생성 \(HTML연결, 마운트\)**
   * `mounted` \(html 문서에 특정 동작을 걸기 위해서는 mount후에 사용 \(자주쓴다\) \)

   1. element가 업데이트 된다면 업데이트 전에는 beforeUpdate , 후에는 updated실행
5. **뷰 모델이 파괴호출되었을때 \( `vm.$destroy()` \)**
   * `beforeDestroy` 함수 실행 \(파괴는 아직이기 때문에 데이터를 백업하거나 할수 있다. \)
6. **뷰 모델 파괴됨** \(watch , 소속된 컴포넌트들의 이벤트 연결 해제 , 반응성 제거 \)
   * `destroyed` 함수 실행

이중에서 가장 자주 사용되는 훅으로는 **created** , **mounted**가 있겠습니다. 

자 한번 예제 코드를 살펴볼까요 ? 

```markup
<body>
    <div id="app">
        <h1>{{msg}} </h1>
    </div>
    <script>
        const vm = new Vue({
            el:'#app',
            data:{
                msg:'Hello Vue!',
            },
            beforeCreate(){
                console.log('BeforeCreate!');
            },
            created(){
                console.log('Created');
            },
            beforeMount(){
                console.log('BeforeMount!');
            },
            mounted(){
                console.log('Mounted');
            }
        })
    </script>
</body>

```

![](../.gitbook/assets/image%20%2838%29.png)

순서대로 출력된것 처럼 보일 수도 있지만, 순서를 바꿔도 전혀 상관은 없습니다. 

하지만, 라이프 사이클 실행 순서대로 작성을 해주는 것이 조금더 직관적일 수 있겠죠? 

추가적으로 this.msg도 함께 출력해보도록 하겠습니다. 

### beforeCreate\(\) , created\(\)

먼저 beforeCreate\(\) 와 , created\(\)에서 this.message를 함께 출력해 볼까요? 

```markup
beforeCreate(){
   console.log('BeforeCreate!',this.msg);
},
created(){
   console.log('Created',this.msg);
},
```

![](../.gitbook/assets/image%20%2817%29.png)

beforeCreate는 Vue instance가 생성되기 직전이기 때문에 data에 뭐가 있는지 모릅니다. 

### beforeMount\(\) , mounted\(\)

이번에는 HTML element를 참조해보겠습니다. 

```markup
<div id="app">
        <h1>{{msg}} </h1>
        <div ref='div'></div> 
        <!-- div라는 이름으로 참조하겠다. -->
</div>
========================================
beforeMount(){
    console.log('BeforeMount!',this.$refs.div);
},
mounted(){
    console.log('Mounted',this.$refs.div);
}
```

`this.$refs.div` 는 ref이름이 div라는 요소를 참조한다는 의미입니다. 

![](../.gitbook/assets/image%20%2844%29.png)

BeforeMount는 HTML요소와 Vue instance가 **연결되기 이전**이기때문에 **undifined**가 출력됩니다. 

### beforeUpdate\(\) , updated\(\)

```markup
<div id="app">
    <h1 ref='msg'>{{msg}} </h1>
    <div ref='div'></div> 
</div>

===============================================

beforeUpdate(){
    console.log('beforeUpdate',this.$refs.msg)
},
updated(){
    console.log('Updated',this.$refs.msg)
}
```

update관련 훅들은 update가 진행되야 실행되기 때문에 콘솔에 아무것도 출력되지 않을 것입니다. 

한번 직접 msg값을 업데이트 해보세요.

![](../.gitbook/assets/image%20%2829%29.png)

beforeUpdate는 **업데이트가 되기 직전**의 상태를 출력해 주었습니다. 

단, msg데이터를 `this.msg` 이런형식으로 직접 출력해주면 다음과 같은 결과가 나옵니다. 

![](../.gitbook/assets/image%20%2812%29.png)

{% hint style="warning" %}
watch 인스턴스와 함께 사용하면, 예기치 못한 에러가 일어날 수 있으니, 조심해서 사용합시다!
{% endhint %}

### BeforeDestroy\(\) , Destroyed\(\)

```markup
beforeDestroy(){
    console.log('beforeDestroy!')
},
destroyed(){
    console.log('Destroy')
}
```

마찬가지로 실행하면 , vm이 제거되지 않았기 때문에 아무것도 출력되지 않을 것입니다. 

하지만, `vm.$destroy()` 메소드를 통해 파괴시킬 수 있습니다. 

![](../.gitbook/assets/image%20%282%29.png)

이렇게 파괴를 시키면 반응성이 없어지는 등, 뷰 인스턴스의 역할을 수행할 수 없습니다. 

많이 쓸 일은 없겠지만, 더이상 필요가 없어서, 메모리를 정리할때 쯤 사용할 수 있을 것 같습니다. 

